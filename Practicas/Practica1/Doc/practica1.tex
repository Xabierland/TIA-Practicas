\documentclass{report}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx, longtable, float, titlesec, hyperref, enumitem, dingbat, soul, multicol, listings}
\usepackage[dvipsnames]{xcolor}
\usepackage[margin=2cm]{geometry}

% Cambia el color de los links
\hypersetup{
    hidelinks = true
}

% Python Code
\lstdefinestyle{Python}{
  commentstyle=\color{brown},
  keywordstyle=\color{violet},
  numberstyle=\tiny\color{gray},
  stringstyle=\color{purple},
  basicstyle=\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=left,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2,
  literate={ñ}{{\~n}}1 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
}
\lstset{style=Python}

% Elimina la palabra "Capítulo" de los títulos de los capítulos
\titleformat{\chapter}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge\thechapter.\space}

\titleformat{name=\chapter,numberless}[display]
  {\normalfont\bfseries}{}{0pt}{\Huge}

\titlespacing*{\chapter}{0pt}{-50pt}{20pt}

% Añade numeración a los subsubsections y los añade al índice
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\begin{document}
    \begin{titlepage}
        \centering
        \includegraphics[width=0.6\textwidth]{./.img/logo.jpg}\\
        \vspace{1cm}
        \LARGE Técnicas de Inteligencia Artificial\\
        \vspace{0.5cm}
        \Large Ingeniería Informática de Gestión y Sistemas de Información\\
        \vspace{3cm}
        \Huge Practica 1\\
        \huge Problemas de Búsqueda\\
        \vspace{2.5cm}
        \Large Autor(es):\\
        \vspace{0.2cm}
        \large Xabier Gabiña\\
        \vfill
        \today
    \end{titlepage}
    \tableofcontents
    \chapter{Introducción}
      {
        En el marco de la asignatura de Técnicas de Inteligencia Artificial, se nos ha propuesto implementar y analizar diversos algoritmos de búsqueda aplicados al contexto de un proyecto académico desarrollado por la Universidad de Berkeley, basado en el clásico juego Pacman. El objetivo principal de esta práctica es profundizar en el funcionamiento de diferentes estrategias de búsqueda, estudiando su eficiencia y comportamiento en diferentes escenarios.\\

        Los algoritmos de búsqueda son fundamentales en el campo de la inteligencia artificial, ya que permiten encontrar soluciones óptimas o satisfactorias en problemas complejos. En esta práctica, nos enfocaremos en tres tipos de algoritmos de búsqueda no informados: Depth First Search (DFS), Breadth First Search (BFS) y Uniform Cost Search (UCS). Además, exploraremos un algoritmo de búsqueda informado: A*. Cada uno de estos algoritmos tiene sus propias características y aplicaciones, y su estudio nos permitirá comprender mejor sus ventajas y limitaciones.\\

        A lo largo de este documento, se presentarán las implementaciones de cada uno de estos algoritmos, junto con una descripción detallada de su funcionamiento y análisis de su rendimiento. Se incluirán ejemplos prácticos y se discutirán los resultados obtenidos en diferentes escenarios de búsqueda. El objetivo es proporcionar una visión completa y comprensiva de cómo estos algoritmos pueden ser aplicados en la resolución de problemas de búsqueda en inteligencia artificial.\\
      }
    \chapter{Algoritmos no informados}
      \section{DFS - Depth First Search}
        \subsection*{Descripción}
          \paragraph*{}{
            DFS o Depth First Search es un algoritmo de búsqueda no informado que se basa en la exploración de todos los nodos de un grafo siguiendo una rama hasta llegar a un nodo hoja, para después retroceder y explorar otra rama.\\
            Este algoritmo se implementa mediante una pila, en la que se van almacenando los nodos a visitar.\\
            Su coste en tiempo es de O(b\textsuperscript{m}), donde b es el factor de ramificación y m es la profundidad máxima del árbol.\\
            Su coste en espacio es de O(bm), donde b es el factor de ramificación y m es la profundidad máxima del árbol.\\
          }  
        \subsection*{Primera implementación}
          \begin{lstlisting}[language=Python, caption=Implementación final del DFS]
def depthFirstSearch(problem):
"""
Implementación del algoritmo de búsqueda en profundidad.

Args:
    problem (SearchProblem): Problema de búsqueda
Returns:
    list: Lista de acciones para llegar al objetivo
"""
  stack = [problem] # Pila para almacenar los nodos a visitar
  visited = set()     # Conjunto para almacenar los nodos visitados
  path = []           # Lista para almacenar el camino al nodo objetivo

  while stack:    # Mientras haya elementos en el stack
      nodo_actual = stack.pop()   # Sacar el último elemento de la pila
      if nodo_actual in visited:  # Si el nodo actual ya ha sido visitado
          continue
      visited.add(nodo_actual)   # Marcar el nodo actual como visitado
      path.append(nodo_actual.contenido)  # Añadir el nodo actual al camino
      if nodo_actual.isGoalState():  # Si el nodo actual es el objetivo
          return path
      for hijo in reversed(nodo_actual.getSuccesor()): # Añadir los hijos del nodo actual a la pila
          stack.append(hijo)
          \end{lstlisting}
        \clearpage\subsection*{Implementación Final}
          \begin{lstlisting}[language=Python, caption=Implementación final del DFS]
def depthFirstSearch(problem):
"""
Implementación del algoritmo de búsqueda en profundidad.

Args:
    problem (SearchProblem): Problema de búsqueda
Returns:
    list: Lista de acciones para llegar al objetivo
"""
stack = util.Stack()  # Añadir el nodo inicial a la pila
stack.push([problem.getStartState(), []])
visited = set()  # Conjunto para almacenar los nodos visitados

while not stack.isEmpty():  # Mientras haya elementos en el stack
    nodo_actual = stack.pop()  # Sacar el último elemento de la pila
    if problem.isGoalState(nodo_actual[0]):  # Si el nodo actual es el objetivo
        return nodo_actual[1]  # Devolver el camino
    if nodo_actual[0] not in visited:
        visited.add(nodo_actual[0])
        for estado, accion, costo in reversed(problem.getSuccessors(nodo_actual[0])): 
            camino = nodo_actual[1] + [accion]
            stack.push([estado, camino])
          \end{lstlisting}
        \subsection*{Comentarios}
          \paragraph*{}{

          }
      \clearpage\section{BFS - Breadth First Search}
        \subsection*{Descripción}
          \paragraph*{}{
            BFS o Breath First Search es un algoritmo de búsqueda no informado que se basa en la exploración de todos los nodos de un grafo nivel por nivel. Este algoritmo se implementa mediante una cola en la que se van almacenando los nodos que se deben visitar, manteniendo un orden de llegada basado en los niveles.\\ 
            Su coste en tiempo es de O(b\textsuperscript{d}), donde b es el factor de ramificación y d es la profundidad del nodo más cercano del árbol y su coste en espacio es de O(b\textsuperscript{d}), ya que debe almacenar todos los nodos del nivel actual antes de pasar al siguiente.\\
          }
        \subsection*{Implementación Final}
          \begin{lstlisting}[language=Python, caption=Implementación final del BFS]
def breadthFirstSearch(problem):
"""
Implementacion del algoritmo de busqueda en anchura.

Args:
    problem (SearchProblem): Problema de busqueda
Returns:
    list: Lista de acciones para llegar al objetivo
"""
queue = util.Queue()  # Añadir el nodo inicial a la cola
queue.push([problem.getStartState(), []])
visited = set()     # Conjunto para almacenar los nodos visitados

while not queue.isEmpty():    # Mientras haya elementos en la cola
    nodo_actual = queue.pop()   # Sacar el primer elemento de la cola
    if problem.isGoalState(nodo_actual[0]):  # Si el nodo actual es el objetivo
        return nodo_actual[1]  # Devolver el camino
    if nodo_actual[0] not in visited:
        visited.add(nodo_actual[0])
        for estado, accion, costo in problem.getSuccessors(nodo_actual[0]): # Añadir los hijos del nodo actual a la cola
            camino = nodo_actual[1] + [accion]
            queue.push([estado, camino])
          \end{lstlisting}
        \subsection*{Comentarios}
      \clearpage\section{UCS - Uniform Cost Search}
        \subsection*{Descripción}
          \paragraph*{}{
            UCS o Uniform Cost Search es un algoritmo de búsqueda no informada que expande los nodos en función del costo acumulado. En contrario al BFS que prioriza la profundidad de los nodos el UCS utiliza la cola de prioridad para ordenar los nodos dependiendo su costo acumulado y expande primero el nodo con menor costo, obteniendo así una solución óptima en términos de costo.\\  
            El coste en tiempo del UCS es de \( O(b^{1 +\frac{ C^*}{\varepsilon}}) \), donde b es el factor de ramificación, C* es el costo de la solución óptima y \( \varepsilon \)  es el menor costo de transición entre nodos. Su coste de espacio es así mismo \( O(b^{1 +\frac{ C^*}{\varepsilon}}) \) ya que debe de almacenar todos los nodos en la cola de prioridad hasta encontrar la solución óptima \\
          }
        \subsection*{Implementación Final}
            \begin{lstlisting}[language=Python, caption=Implementación final del UCS]
def uniformCostSearch(problem):
"""
Implementacion del algoritmo de busqueda de coste uniforme.

Args:
    problem (SearchProblem): Problema de busqueda
Returns:
    list: Lista de acciones para llegar al objetivo
"""
queue = util.PriorityQueue()  # Añadir el nodo inicial a el heap
queue.push([problem.getStartState(), [], 0], 0)
visited = set()     # Conjunto para almacenar los nodos visitados

while not queue.isEmpty():    # Mientras haya elementos en el stack
    nodo_actual = queue.pop()   # Sacar el último elemento de la pila
    if problem.isGoalState(nodo_actual[0]):  # Si el nodo actual es el objetivo
        return nodo_actual[1]  # Devolver el camino
    if nodo_actual[0] not in visited:
        visited.add(nodo_actual[0])
        for estado, accion, costo in problem.getSuccessors(nodo_actual[0]): # Añadir los hijos del nodo actual a la pila
            camino = nodo_actual[1] + [accion]
            queue.push([estado, camino, nodo_actual[2] + costo], nodo_actual[2] + costo)
            \end{lstlisting}
        \subsection*{Comentarios}
          \paragraph*{}{

          }
    \chapter{Algoritmos informados}
      \section{A*}
        \subsection*{Descripción}
          \paragraph*{}{
            El A* es un algoritmo de búsqueda informada que utiliza las ventajas del UCS y Greedy Best-First Search, utilizando una función heurística para guiar la búsqueda hacia el objetivo de una manera más eficiente. A* expande los nodos en mediante una función de costo total. Donde f(n) = g(n) + h(n), g(n) siendo el costo acumulado desde el nodo inicial hasta n y h(n) es una estimación heurística del costo n hasta el objetivo. Este algoritmo se implementa mediante una cola de prioridad , donde los nodos se ordenan según su valor f(n) y se expande primero el nodo con menor valor f(n).\\
            Su coste en tiempo es de O(b\textsuperscript{d}), donde b es el factor de ramificación y d es la profundidad de la solución óptima, sin embargo el tiempo puede reducirse si la heurística es eficiente. Así mismo su coste de espacio es de  O(b\textsuperscript{d}), ya que se debe de almacenar todos los nodos generados en la cola de prioridad para asegurar la solución óptima.
          }
        \subsection*{Implementación Final}
          \begin{lstlisting}[language=Python, caption=Implementación final del A*]
def aStarSearch(problem, heuristic=nullHeuristic):
"""
Implementacion del algoritmo de busqueda A*.

Args:
    problem (SearchProblem): Problema de busqueda
    heuristic (function): Heuristica para el problema
Returns:
    list: Lista de acciones para llegar al objetivo
"""
queue = util.PriorityQueue()  # Añadir el nodo inicial a el heap
queue.push([problem.getStartState(), [], 0], 0)
visited = set()     # Conjunto para almacenar los nodos visitados

while not queue.isEmpty():    # Mientras haya elementos en el stack
    nodo_actual = queue.pop()   # Sacar el último elemento de la pila
    if problem.isGoalState(nodo_actual[0]):  # Si el nodo actual es el objetivo
        return nodo_actual[1]  # Devolver el camino
    if nodo_actual[0] not in visited:
        visited.add(nodo_actual[0])
        for estado, accion, costo in problem.getSuccessors(nodo_actual[0]): # Añadir los hijos del nodo actual a la pila
            camino = nodo_actual[1] + [accion]
            queue.push([estado, camino, nodo_actual[2] + costo], nodo_actual[2] + costo + heuristic(estado, problem))        
          \end{lstlisting}
        \subsection*{Comentarios}
          \paragraph*{}{
          }
    \chapter{Resultados}
      \section{Casos de pruebas}
      \section{Autograder}
          \begin{lstlisting}
Starting on 10-1 at 17:38:32

Question q1
===========

*** PASS: test_cases/q1/graph_backtrack.test
***     solution:               ['1:A->C', '0:C->G']
***     expanded_states:        ['A', 'B', 'C']
*** PASS: test_cases/q1/graph_bfs_vs_dfs.test
***     solution:               ['0:A->B', '0:B->D', '0:D->G']
***     expanded_states:        ['A', 'B', 'D']
*** PASS: test_cases/q1/graph_infinite.test
***     solution:               ['0:A->B', '1:B->C', '1:C->G']
***     expanded_states:        ['A', 'B', 'C']
*** PASS: test_cases/q1/graph_manypaths.test
***     solution:               ['0:A->B1', '0:B1->C', '0:C->D', '0:D->E1', '0:E1->F', '0:F->G']
***     expanded_states:        ['A', 'B1', 'C', 'D', 'E1', 'F']
*** PASS: test_cases/q1/pacman_1.test
***     pacman layout:          mediumMaze
***     solution length: 246
***     nodes expanded:         269

### Question q1: 3/3 ###


Question q2
===========

*** PASS: test_cases/q2/graph_backtrack.test
***     solution:               ['1:A->C', '0:C->G']
***     expanded_states:        ['A', 'B', 'C', 'D']
*** PASS: test_cases/q2/graph_bfs_vs_dfs.test
***     solution:               ['1:A->G']
***     expanded_states:        ['A', 'B']
*** PASS: test_cases/q2/graph_infinite.test
***     solution:               ['0:A->B', '1:B->C', '1:C->G']
***     expanded_states:        ['A', 'B', 'C']
*** PASS: test_cases/q2/graph_manypaths.test
***     solution:               ['1:A->C', '0:C->D', '1:D->F', '0:F->G']
***     expanded_states:        ['A', 'B1', 'C', 'B2', 'D', 'E1', 'F', 'E2']
*** PASS: test_cases/q2/pacman_1.test
***     pacman layout:          mediumMaze
***     solution length: 68
***     nodes expanded:         269

### Question q2: 3/3 ###


Question q3
===========

*** PASS: test_cases/q3/graph_backtrack.test
***     solution:               ['1:A->C', '0:C->G']
***     expanded_states:        ['A', 'B', 'C', 'D']
*** PASS: test_cases/q3/graph_bfs_vs_dfs.test
***     solution:               ['1:A->G']
***     expanded_states:        ['A', 'B']
*** PASS: test_cases/q3/graph_infinite.test
***     solution:               ['0:A->B', '1:B->C', '1:C->G']
***     expanded_states:        ['A', 'B', 'C']
*** PASS: test_cases/q3/graph_manypaths.test
***     solution:               ['1:A->C', '0:C->D', '1:D->F', '0:F->G']
***     expanded_states:        ['A', 'B1', 'C', 'B2', 'D', 'E1', 'F', 'E2']
*** PASS: test_cases/q3/ucs_0_graph.test
***     solution:               ['Right', 'Down', 'Down']
***     expanded_states:        ['A', 'B', 'D', 'C', 'G']
*** PASS: test_cases/q3/ucs_1_problemC.test
***     pacman layout:          mediumMaze
***     solution length: 68
***     nodes expanded:         269
*** PASS: test_cases/q3/ucs_2_problemE.test
***     pacman layout:          mediumMaze
***     solution length: 74
***     nodes expanded:         260
*** PASS: test_cases/q3/ucs_3_problemW.test
***     pacman layout:          mediumMaze
***     solution length: 152
***     nodes expanded:         173
*** PASS: test_cases/q3/ucs_4_testSearch.test
***     pacman layout:          testSearch
***     solution length: 7
***     nodes expanded:         14
*** PASS: test_cases/q3/ucs_5_goalAtDequeue.test
***     solution:               ['1:A->B', '0:B->C', '0:C->G']
***     expanded_states:        ['A', 'B', 'C']

### Question q3: 3/3 ###


Question q4
===========

*** PASS: test_cases/q4/astar_0.test
***     solution:               ['Right', 'Down', 'Down']
***     expanded_states:        ['A', 'B', 'D', 'C', 'G']
*** PASS: test_cases/q4/astar_1_graph_heuristic.test
***     solution:               ['0', '0', '2']
***     expanded_states:        ['S', 'A', 'D', 'C']
*** PASS: test_cases/q4/astar_2_manhattan.test
***     pacman layout:          mediumMaze
***     solution length: 68
***     nodes expanded:         221
*** PASS: test_cases/q4/astar_3_goalAtDequeue.test
***     solution:               ['1:A->B', '0:B->C', '0:C->G']
***     expanded_states:        ['A', 'B', 'C']
*** PASS: test_cases/q4/graph_backtrack.test
***     solution:               ['1:A->C', '0:C->G']
***     expanded_states:        ['A', 'B', 'C', 'D']
*** PASS: test_cases/q4/graph_manypaths.test
***     solution:               ['1:A->C', '0:C->D', '1:D->F', '0:F->G']
***     expanded_states:        ['A', 'B1', 'C', 'B2', 'D', 'E1', 'F', 'E2']

### Question q4: 3/3 ###


Question q5
===========

*** Method not implemented: getStartState at line 311 of searchAgents.py
*** FAIL: Terminated with a string exception.

### Question q5: 0/3 ###


Question q6
===========

*** Method not implemented: getStartState at line 311 of searchAgents.py
*** FAIL: Terminated with a string exception.

### Question q6: 0/3 ###


Question q7
===========

*** PASS: test_cases/q7/food_heuristic_1.test
*** FAIL: test_cases/q7/food_heuristic_10.test
*** Heuristic failed non-triviality test
*** Tests failed.

### Question q7: 0/4 ###


Question q8
===========

[SearchAgent] using function depthFirstSearch
[SearchAgent] using problem type PositionSearchProblem
Warning: this does not look like a regular search maze
*** Method not implemented: findPathToClosestDot at line 511 of searchAgents.py
*** FAIL: Terminated with a string exception.

### Question q8: 0/3 ###


Finished at 17:38:32

Provisional grades
==================
Question q1: 3/3
Question q2: 3/3
Question q3: 3/3
Question q4: 3/3
Question q5: 0/3
Question q6: 0/3
Question q7: 0/4
Question q8: 0/3
------------------
Total: 12/25

Your grades are NOT yet registered.  To register your grades, make sure
to follow your instructor's guidelines to receive credit on your project.
          \end{lstlisting}
\end{document}